# Examples and Use Cases

| Case | Go to | Description or Ideas |
| ---  | ---   | --- |
|  Iterate over paginated data | [Use async generator](./02_enhancing_with_generators/notes.md#iterating-over-paginated-data)  | asynchronous generators allow us to smoothly and continuously make several network requests and iterate over the results. |
|  Fetching images from a photo sharing website like Flickr | [Use async generator](./02_enhancing_with_generators/notes.md#other)  | The Flickr API provides an endpoint for fetching images based on given keywords. With an async generator function, you can fetch and navigate the batches asynchronously. Using an async generator would also open up the possibility to seamlessly aggregate photos from several sources. |
|  Retrieve data from different sources (like files) and/or APIs| [Use `Promise.any() or .allSettled()`](./03_fetching_multiple_resources/notes.md#other)  | You will want to use these methods only when you need to process the result of multiple async requests together. If it’s possible to process the result of each async request individually, then handle each promise with its own `then()` handler. This way, you can execute your code as soon as each promise is resolved. |
| Provide alternative APIs in case one is not available | [Use `Promise.any()`](./04_improving_reliability_and_performance/notes.md#avoiding-the-single-point-of-failure) | The `Promise.any()` method is extremely useful in this regard. It enables us to request data from multiple APIs and use the result of the first successful promise. This also improves the performance (only the first and fastest is used, as soon it is ready) |
| Setting a time limit for async. tasks | [Use `Promise.race()`](./05_setting_a_time_limit_for_async_tasks.md/notes.md#enforcing-a-time-limit-for-async-tasks) | Depending on the promise that settles first, we either obtain the result or report an error message. In other words, we represent each outcome with a promise: the successful fetching from the API, or its failure. |
| Loading cached data in case fresh data from API is not available | [Use `Promise.race()`](./05_setting_a_time_limit_for_async_tasks.md/notes.md#improving-the-program-with-cached-data) | See above. |
| Batch async. requests | [Use `Promise.race()`](./05_setting_a_time_limit_for_async_tasks.md/notes.md#other-use-cases) | If you have to make numerous async requests and don’t want the pending requests to get out of hand, you can use `Promise.race()` “to keep a fixed number of parallel promises running and add one to replace whenever one completes.” Using `Promise.race()` in this way lets you run multiple jobs in a batched way while preventing too much work from happening at one time. | 
| A computationally expensive background task | [Use `Promise.race()`](./05_setting_a_time_limit_for_async_tasks.md/notes.md#other-use-cases) | It’s easy to imagine cases where some task might be attempted in the background, such as rendering a complex canvas while the user is occupied with something else. Using `Promise.race()` there, again gives you some knowable time to work with—and the opportunity to introduce some logic of what to do should the task fail. |
| Cancel a pending async request | [Use `AbortController`](./06_canceling_pending_async_requests/notes.md#canceling-pending-async-requests) | Perhaps you have a network-intensive application and async requests are taking too long to fulfill, or maybe the user clicked a Cancel button. |
| Create a custom `fetch` request maker with auto timeout | [Use `AbortController`](./06_canceling_pending_async_requests/notes.md#custom-fetch-maker) | We can add an abort interface to every request automatically |
| Removing multiple event listeners at the same time | [Use `AbortController`](./06_canceling_pending_async_requests/notes.md#removing-multiple-event-listeners) | We can abort multiple fetch requests with a single `AbortSignal` |
| Disable drag and drop listeners to multiple elements | [Use `AbortController`](./06_canceling_pending_async_requests/notes.md#removing-multiple-event-listeners) | See above. |
| Load a heavy image with the possibility to cancel loading | [Use `AbortController`](./06_canceling_pending_async_requests/notes.md#use-case-loading-a-heavy-image-22-mb-with-a-load-and-a-cancel-buttons) | See above. |
| Load a gallery of images with the possibility to cancel loading | [Use `AbortController`](./06_canceling_pending_async_requests/notes.md#aborting-multiple-fetch-requests-with-one-signal) | See above. |
| Canceling stale requests in live search inputs | [Use `AbortController`](./06_canceling_pending_async_requests/notes.md#other) | See above. |
| Wait for data from other modules | [Use top-level `await`](./07_accessing_promise_results_from_another_module/notes.md) | By using top-level await, we can make the module behave like a big async function. We can now represent resources with `await` and handle errors if the module can’t be used. Remember, a module won’t start evaluating its body until the module that’s being imported has finished executing its body. So if the other module has a top-level `await`, it must be completed before the module that’s importing it begins executing. |

